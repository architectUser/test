Es6
一.
（1）let用法：
          1.定义变量
          2.不存在变量提升
          3.暂时性死区
          4.不允许重复申明

（2）块级作用域
         1.es5只有全局作用域和函数作用域，所以需要块级作用域
          缺点：1.内层变量可能会覆盖外层作用域
                2.用来计数的循环变量泄露为全局变量
         2.块级作用域可以任意嵌套
         3.内层作用域可以定义外层作用域的同名变量
（3）块级作用域与函数声明
      es5规定：函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明
      es6： 允许在块级作用域之中声明函数。es规定，在块级作用域之中，函数申明语句的行为类似于let，在块级作用域之外不可引用
      es6有3中规则：
      1.允许在块级作用域内声明函数
      2.函数申明类似于var，即会提升到全局作用域或函数作用域的头部。
      3.同时，函数声明还会提升到所在的块级作用域的头部
（4）do表达式
块级作用域的本质是一个语句，将多个操作封装在一起，没有返回值。
{
   let t = f（）;
   t * t + 1;
}
将块级作用域可以变成表达式，即可以返回值，方法是在块级作用域之前加上do，使它变成do表达式。
let x = do {
   let t = f（）;
   t * t + 1;
}

(5)const 命令
声明一个只读的常量。一旦声明，常量的值不能被改变
1.const的作用域与let命令相同：只在声明所在的块级作用域内有效
2.const声明的常量也不会提升，同样存在暂时性死区，只能在声明后使用。
3.与let一样，不可重复声明
const本质
const不是指变量的值不得改动，而是变量指向的内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值）而言，
值就保存在变量指向的内存地址中，因此等同于常量。但对于复合类型的数据（主要是对象和数组）而言，变量指向的内存地址
保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。因此，将一个
对象声明为常量时必须小心。

















